import esquery from 'esquery'

export default {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow `.bind()` or arrow functions in JSX props (`react/jsx-no-bind`)",
      },
      fixable: "code",
      schema: [
        {
          type: "object",
          properties: {
            allowArrowFunctions: { type: "boolean", default: false },
            allowBind: { type: "boolean", default: false },
          },
        },
      ],
    },
    create: function(context) {
      const options = context.options[0] || {};
      const {
        allowArrowFunctions = false,
        allowBind = false,
      } = options;
      const sourceCode = context.getSourceCode();
  

      /**
       * *********************************************
       * Comienzo de funciones comunes
       * *********************************************
       */

      /**
       * @param {*} node Nodo en el que se produce la detección
       * @param {*} message Mensaje de error/aviso
       * @param {*} fix Corrección en caso de tenerla
       */
      function report(node, message, fix) {
        context.report({
          node: node,
          message: message,
          fix: fix,
        });
      }
      

      /**
       * Encuentra el primer nodo que no sea import.
       * @param {*} sourceCode 
       * @param {*} node 
       * @returns 
       */
      function findFirstNonImportNode(sourceCode, node){
        // Encuentra el primer nodo no import en el archivo para insertar la importación al principio
        return sourceCode.ast.body.find(node => node.type !== 'ImportDeclaration');
      }

      /**
       * Genera la sentencia de importación de useCallback en caso de no tenerla, sino devuelve ''
       * @param {*} sourceCode 
       * @returns 
       */
      function generateImportForCallback(sourceCode){
        return sourceCode.text.includes('useCallback')
        ? ''
        : "import { useCallback } from 'react';\n\n";
      }


      function generateNameForCallbackMethods(){
        return `autoGeneratedCallback`
      }


      
      /**
       * *********************************************
       * Comienzo de funciones para Bind(this)
       * *********************************************
       */
  
      /**
       * Comprueba si el nodo es una expresión que usa bind() de un solo argumento o no
       * @param {*} node 
       * @returns Boolean
       */
      function isBindExpression(node) {
        return (
          node && 
          node.type === 'JSXExpressionContainer' && 
          node.expression &&
          node.expression.type === "CallExpression" &&
          node.expression.callee &&
          node.expression.callee.property &&
          node.expression.callee.property.name === "bind" &&
          node.expression.arguments.length === 1 &&
          node.expression.arguments[0].type === "ThisExpression"
        );
      }
  
      /**
       * Arreglar la expresion .bind() con la creacion y la llamada de un metodo callback
       * @param {*} node 
       * @returns 
       */
      function fixBindExpression(node) {

        //Import para insertar
        const importStatement = generateImportForCallback(sourceCode);

        // Construir el código para el método con useCallback
        const methodName = generateNameForCallbackMethods();
        const calleeText = sourceCode.getText(node.callee.object);
        const methodDeclaration = `const ${generateNameForCallbackMethods()} = useCallback(${calleeText}, []);\n\t`;

        // Buscar el nodo FunctionDeclaration o FunctionExpression más cercano para insertar
        const parentNode = sourceCode.getAncestors(node).find(
          ancestor => ancestor.type === 'FunctionDeclaration' || ancestor.type === 'FunctionExpression'
        );

        // Encontrar el índice del nodo de retorno en el cuerpo del padre para insertarlo y que no de errores
        const indexOfReturn = parentNode.body.body.findIndex(child => child.type === 'ReturnStatement');

        //Nodo para insertar el import del callback
        const firstNonImportNode = findFirstNonImportNode(sourceCode);

        return fixer => [
          fixer.insertTextBefore(firstNonImportNode, importStatement),
          fixer.insertTextBefore(parentNode.body.body[indexOfReturn], methodDeclaration),
          // Reemplazar el .bind() con el nuevo método con useCallback
          fixer.replaceText(node, methodName),
        ];
      }


      /**
       * *********************************************
       * Comienzo de funciones para ArrowFunction
       * *********************************************
       */

      /**
       * Comprueba si la función es una ArrowFunction
       * @param {*} node 
       * @returns boolean
       */
      function isArrowFunction(node){
        return (
          node &&
          node.type === "JSXExpressionContainer" &&
          node.expression.type === "ArrowFunctionExpression"
        );
      }


      function fixArrowFunctionExpression(node) {

        //Import para insertar
        const importStatement = generateImportForCallback(sourceCode);

        //Metodo para insertar
        const methodName = generateNameForCallbackMethods();
        const arrowFunctionText = sourceCode.getText(node);
        const variableIdentifiers = searchVariablesForCallback(node);        
        const methodDeclaration = `const ${methodName} = useCallback(${arrowFunctionText}, [${variableIdentifiers}]);\n\t`;

        // Encuentra el primer nodo no import en el archivo para insertar la importación al principio
        const firstNonImportNode = sourceCode.ast.body.find(node => node.type !== 'ImportDeclaration');

        //Encuentra el nodo padre del lugar donde se encontraba la arrowFunction para insertar la nueva funcion Callback
        const nodeToInsert = sourceCode.getAncestors(node).find(ancestor => {
          return ancestor.type === 'FunctionDeclaration' || ancestor.type === 'FunctionExpression';
        });

        return fixer => [
          fixer.insertTextBefore(firstNonImportNode, importStatement),
          fixer.insertTextBefore(nodeToInsert.body.body[0], methodDeclaration),
          fixer.replaceText(node, methodName),
        ];
      }

      /**
       * Busca las variables utilizadas dentro de un nodo para poder añadirlas al Callback
       * @param {*} node 
       * @returns Lista de variables separadas por ,
       */
      function searchVariablesForCallback(node){
        // Utiliza esquery para encontrar todos los Identifiers dentro de node pasado como parametro
        const identifiers = esquery(node, 'Identifier');
      
        // Filtra los Identifiers que son variables comparando la lista de identificadores del nodo con la lista de variables global
        // y quita de la lista los que sean nombres de funciones
        const variablesListOfNode = identifiers.filter(identifier => {
          const variable = context.getScope().variables.find(v => v.name === identifier.name);
          return variable && !variable.defs.some(def => def.type === 'FunctionName');
        });
      
        // Utiliza un conjunto para evitar duplicados
        const uniqueVariables = new Set(variablesListOfNode.map(v => v.name));
      
        return Array.from(uniqueVariables).join(', ');
      }

      

      return {
        JSXAttribute: function(node) {
          if (isBindExpression(node.value)) {
            if(!allowBind){
              report(node, 'Avoid using .bind() in JSX props.', fixBindExpression(node.value.expression));
            }
          }else if (isArrowFunction(node.value)){
            if(!allowArrowFunctions){
              report(node, 'Avoid using arrow functions in JSX props.', fixArrowFunctionExpression(node.value.expression));
            }
          }
        },
      };
    },
  };
  